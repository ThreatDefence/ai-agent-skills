# Escalation Playbook

Use this reference when an alert needs to be pushed beyond routine closure. It covers creating escalations, sending notifications, and preserving console context.

## 1. Create or Update an Escalation Record

```
curl -s -X PUT \
  -H "Authorization: ApiKey ${THREATDEFENCE_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "analyst_notes": "Plaintext credential in Naz.API leak; needs customer confirmation."
      }' \
  "${THREATDEFENCE_API_BASE}/msps/${MSP}/tenants/${TENANT}/alerts/${ALERT_ID}/escalations"
```

- Returns a JSON body with `msg` containing the escalation UUID. Save that ID for downstream channels.
- Include console links in `analyst_notes` whenever possible so humans are one click away from context.

## 2. Email Escalation (Customer / Exec)

```
ESCALATION_ID="<uuid returned above>"

payload=$(cat <<'JSON'
{
  "subject": "Critical dark web leak ({{ALERT_SHORT_SOURCE}}) – {{TENANT_NAME}}",
  "to": ["{{PRIMARY_CONTACT_EMAIL}}"],
  "cc": ["{{SECONDARY_CONTACT_EMAIL}}"],
  "bcc": []
}
JSON
)

curl -s -X PUT \
  -H "Authorization: ApiKey ${THREATDEFENCE_API_KEY}" \
  -H "Content-Type: application/json" \
  -d "$payload" \
  "${THREATDEFENCE_API_BASE}/msps/${MSP}/tenants/${TENANT}/alerts/${ALERT_ID}/escalations/${ESCALATION_ID}/emails"
```

- Subject line should summarize impact + source.
- Body is autogenerated from the alert comment history; make sure prior notes explain the situation.

## 3. Other Channels

The API supports Telegram, Jira, and webhook notifications under `.../messages`, `.../issues`, and `.../webhooks` respectively. Reuse the same `ESCALATION_ID` and payload schema (`service.EscalationNotification`).

## 4. Workflow Tips

- Record the escalation ID and destination in the alert’s comment for audit trails.
- Keep escalation notes high-signal: what happened, why it matters, what you want the recipient to do.
- Close the loop by updating the alert once the customer responds (status + root cause).
